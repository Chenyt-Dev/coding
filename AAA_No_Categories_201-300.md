### 201. Bitwise AND of Numbers Range 
* So many tricks in bits.

### 202. Happy Number 
* Two pointers could save space. Using set seems has less operations. 

### 203. Remove Linked List Elements 
* Used one pointer. Can also do recursively. 

### 204. Count Primes 
* Used the way to start from 2, then delete all the not prime numbers. 

### 206. Reverse Linked List 
* Both iterative and recursive are fine. Iterative seems easier to write.

### 207. Course Schedule 
* Topology sort. 

### 208. Implement Trie (Prefix Tree) 
* Just implement the Trie tree. 

### 209. Minimum Size Subarray Sum 
* A sliding window question. 

### 210. Course Schedule II 
* Same topology sort, just need to output the order. 

### 211. Design Add and Search Words Data Structure 
* Used trie. For general matching character have to go through each child. 

### 212. Word Search II 
* Trie again. This time need to store the word and do a dfs.

### 213. House Robber II 
* Can reuse helper functions. 

### 214. Shortest Palindrome 
* Learned kmp a little bit. Would be surprised if saw this in an interview. 

### 216. Combination Sum III 
* I just used backtracking. Not sure when will have a problem with only 9 digits. 

### 218. The Skyline Problem 
* Split the buildings to begins and ends. The idea is to record the heights using pq and only put into result list if the highest height changes. 

### 219. Contains Duplicate II 
* Used a set. Not need the exact distance. 

### 220. Contains Duplicate III 
* Used buckets. Need to convert to long before doing operations. Easy to overflow. 

### 221. Maximal Square 
* Used dp. The size is depending on neighbors. 

### 222. Count Complete Tree Nodes 
* With the help of left and right most nodes. 

### 223. Rectangle Area 
* Learned some rectangle calculations. 

### 224. Basic Calculator 
* The ideas for calculators is similar, just use a stack and operate on each character.

### 226. Invert Binary Tree 
* Straightforward if do it recursively. 

### 228. Summary Ranges 
* Just simulate the procedure. 

### 229. Majority Element II 
* Kind of learned a new candidate algorithm. 

### 230. Kth Smallest Element in a BST 
* Used inorder. Can also use stack. 

### 231. Power of Two 
* Used a normal way. But using bit is faster.

### 233. Number of Digit One 
* Haven't taken time on this one. 

### 235. Lowest Common Ancestor of a Binary Search Tree 
* Only 3 situations. 

### 237. Delete Node in a Linked List 
* What's the meaning of this one. 

### 238. Product of Array Except Self 
* Similar to pre sum, this is pre product and post product. 

### 239. Sliding Window Maximum 
* Use Deque. 

### 240. Search a 2D Matrix II 
* Need to increase and decrease for different directions. 

### 241. Different Ways to Add Parentheses 
* Need to find all the results. Recursive and using a memo map. 

### 243. Shortest Word Distance 
* Use two pointers. 

### 244. Shortest Word Distance II 
* Use a map. 

### 245. Shortest Word Distance III 
* Similar, just need to compare the two words. 

### 246. Strobogrammatic Number 
* List the options. 

### 247. Strobogrammatic Number II 
* Recursively generate it. 

### 248. Strobogrammatic Number III 
* Similar idea to generate numbers but can use string compares to verify if in range or not. 

### 249. Group Shifted Strings 
* Made some keys for each group.

### 250. Count Univalue Subtrees 
* Judge by results of subtrees. Update the count when do dfs. 

### 251. Flatten 2D Vector 
* Need to keep it easy. 

### 252. Meeting Rooms 
* Just used the normal way to sort the intervals and then compare begins with last ends.








